#version 450 core
precision highp float;

#define M_PI 3.1415926535897932384626433832795

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D u_Texture;

uniform float u_Amplitude;
uniform float u_Gain;
uniform float u_Frequency;
uniform float u_Scale;
uniform vec2 u_NoiseOffset;
uniform vec2 u_WorldOffset;
uniform vec2 u_GlobalOffset;

vec3 FractBrownNoiseDeriv(in vec2 x);

void main()
{
    vec2 fragCoord = gl_GlobalInvocationID.xy;

    vec3 noiseData = FractBrownNoiseDeriv((fragCoord + u_WorldOffset + u_GlobalOffset) * u_Scale / 10.0);
    noiseData.x += 1.5 * u_Amplitude;
    float height = noiseData.x;
    float du = noiseData.y;
    float dv = noiseData.z;
    vec3 normal = normalize(vec3(-du, 1.0, -dv)) * 0.5 + 0.5;
    vec4 fragColor = vec4(normal, height);

    imageStore(u_Texture, ivec2(fragCoord), fragColor);
}

float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233)))*43758.5453123);
}

// return:
// x: noise value
// y: v.x partial derivative
// z: v.y partial derivative
vec3 NoiseDeriv(in vec2 v) {
  vec2 p = floor(v);
  vec2 w = fract(v);
  vec2 u = w*w*w*(w*(w*6.-15.)+10.); // Quintic interpolation curve
  vec2 du = 30.0*(w-1)*(w-1)*w*w; // Derivative of u

  // Corners
  float a = random(p + vec2(0, 0));
  float b = random(p + vec2(1, 0));
  float c = random(p + vec2(0, 1));
  float d = random(p + vec2(1, 1));

  // Helper variables
  // Assure connectivity along edges
  float k0 = a;
  float k1 = b - a;
  float k2 = c - a;
  float k4 = a - b - c + d;

  // Interpolation
  float noiseValue = k0 + k1 * u.x + k2 * u.y + k4 * u.x * u.y;
  vec2 noiseDeriv = du * vec2(k1 + k4 * u.y, k2 + k4 * u.x);

  return vec3(2.0 * noiseValue - 1.0,  2.0 * noiseDeriv);
}

// 4/5=0.8, 3/5=0.6
// Rotation matrices so the layered noises have a slight rotational offset
// Better seams between chunks
const mat2 m2 = mat2(0.80, 0.60, -0.60, 0.80);
const mat2 m2i = mat2(0.80, -0.60, 0.60, 0.80);

#define OCTAVES 8
vec3 FractBrownNoiseDeriv(in vec2 x) {
  float a = 0.0;
  float b = u_Amplitude;
  vec2 d = vec2(0.0);
  mat2 m = mat2(1.0, 0.0, 0.0, 1.0);

  for (int i = 0; i < OCTAVES; i++)
  {
    vec3 n = NoiseDeriv(x + u_NoiseOffset);
    a += b * n.x;               // accumulate values
    d += b * m * n.yz;          // accumulate derivatives
    b *= u_Gain;                // decrease amplitude every octave
    x = u_Frequency * m2 * x;   // increase frequency 
    m = u_Frequency * m2i * m;  // rotate m so the layers don't stack up
  }

  return vec3(a, d);
}